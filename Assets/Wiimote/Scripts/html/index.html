<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: My Project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('index.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">My Project </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="intro"></a>
Introduction</h1>
<p>This is an easy to use interface between Unity3D (or C# in general with minimal changes) and a Wii Remote controller. The library uses a slightly modified version of <a href="https://github.com/signal11/hidapi">Signal11's HIDAPI</a> to handle low-level bluetooth communications. In essence, the API itself is an implementation of the excellent reverse-engineering effort done at <a href="http://wiibrew.org/wiki/Wiimote">Wiibrew</a>.</p>
<h1 class="doxsection"><a class="anchor" id="find"></a>
Finding Wii Remotes</h1>
<p>To get started with WiimoteAPI, you first need to find a bunch of Wiimote instances to interact with. To do this, you can use WiimoteApi::WiimoteManager::FindWiimotes(). This will update WiimoteApi::WiimoteManager::Wiimotes (a list of active Wiimote instances) with any remotes that have connected since the last check. When you are done using a Wiimote, you can deinitialize it using WiimoteApi::WiimoteManager::Cleanup(Wiimote). This is necessary in order to gracefully cleanup native bluetooth code. Note that there is no hard limit as to how many Wii Remotes can be connected at a time. This limitation is dependent on what bluetooth hardware / drivers you are currently using.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> InitWiimotes() {</div>
<div class="line">    WiimoteManager.FindWiimotes(); <span class="comment">// Poll native bluetooth drivers to find Wiimotes</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">foreach</span>(Wiimote remote <span class="keywordflow">in</span> WiimoteManager.Wiimotes) {</div>
<div class="line">        <span class="comment">// Do stuff.</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> FinishedWithWiimotes() {</div>
<div class="line">    <span class="keywordflow">foreach</span>(Wiimote remote <span class="keywordflow">in</span> WiimoteManager.Wiimotes) {</div>
<div class="line">        WiimoteManager.Cleanup(remote);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="write"></a>
Writing to the Remote</h1>
<p>To write data to a Wii Remote you can use one of the helper functions as defined in WiimoteApi::Wiimote. <em>Be very careful</em> when using these functions, as they take up bluetooth bandwith (e.g. don't send out a ping every frame).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md0"></a>
Setting the Player LED</h4>
<p>To set the 4 LEDs on the bottom of the remote, use WiimoteApi::Wiimote::SendPlayerLED(bool,bool,bool,bool).</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Wiimote remote; <span class="comment">// Initialized previously</span></div>
<div class="line"> </div>
<div class="line">remote.SendPlayerLED(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>); <span class="comment">// LEDs will look like this: [* - - *]</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="write-status"></a>
Requesting a Status Report</h2>
<p>The Wii Remote is capable of sending out "Status Reports" that give basic information such as the battery life of the controller. This data is available through WiimoteApi::Wiimote::Status. These status reports are sent by the Wii Remote automatically when an extension controller is connected or disconnected. You can request a status report yourself using WiimoteApi::Wiimote::SendStatusInfoRequest().</p>
<h2 class="doxsection"><a class="anchor" id="write-rumble"></a>
Rumble</h2>
<p>You can activate or deactivate the Wii Remote's rumble motors by setting WiimoteApi::Wiimote::RumbleOn. Note that <b>setting this flag does not instantly activate rumble</b>. To do that you must send ANY input report (that is, communication from the PC to the remote).</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Wiimote remote; <span class="comment">// Initialized previously</span></div>
<div class="line"> </div>
<div class="line">remote.RumbleOn = <span class="keyword">true</span>; <span class="comment">// Enabled Rumble</span></div>
<div class="line">remote.SendStatusInfoRequest(); <span class="comment">// Requests Status Report, encodes Rumble into input report</span></div>
<div class="line"> </div>
<div class="line">Thread.Sleep(500); <span class="comment">// Wait 0.5s</span></div>
<div class="line"> </div>
<div class="line">remtote.RumbleOn = <span class="keyword">false</span>; <span class="comment">// Disabled Rumble</span></div>
<div class="line">remote.SendStatusInfoRequest(); <span class="comment">// Requests Status Report, encodes Rumble into input report</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="write-datareport"></a>
Changing the Data Report Mode</h2>
<p>The Wii Remote can only send up to 21 bytes of data at a time when reporting over bluetooth. On a low level, it packs different types of data into this memory space, depending on your needs. All of the Wii Remote's report types are represented by the <code>REPORT_XXX</code> types in the WiimoteApi::InputDataType enumeration. You can set the Wii Remote's data reporting mode by using WiimoteApi::Wiimote::SendDataReportMode(InputDataType).</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Wiimote remote; <span class="comment">// Initialized previously</span></div>
<div class="line"> </div>
<div class="line">remote.SendDataReportMode(InputDataType.REPORT_BUTTONS);       <span class="comment">// Only report buttons, when a button is pressed</span></div>
<div class="line"> </div>
<div class="line">remote.SendDataReportMode(InputDataType.REPORT_BUTTONS_ACCEL); <span class="comment">// Report Buttons (as above) and accelerometer data</span></div>
<div class="line"> </div>
<div class="line">remote.SendDataReportMode(InputDataType.REPORT_BUTTONS_EXT19); <span class="comment">// Report Buttons and 19 Extension bytes</span></div>
<div class="line">                                                               <span class="comment">//(useful for Guitar Hero controller, etc.)</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="write-ir"></a>
Initializing the IR Camera</h2>
<p>In order to activate the Wii Remote's IR camera you must first perform a series of steps to calibrate / initialize the camera on the Wii Remote's end. These steps have already been implemented and can be performed by calling WiimoteApi::Wiimote::SetupIRCamera(IRDataType). Note that this will change the Wii remote's data reporting mode (see <em>Changing the Data Report Mode</em>) depending on what IRDataType you choose (See WiimoteApi::IRDataType for more info).</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Wiimote remote; <span class="comment">// Initialized previously</span></div>
<div class="line"> </div>
<div class="line">remote.SetupIRCamera(IRDataType.BASIC);     <span class="comment">// Basic IR dot position data</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// OR...</span></div>
<div class="line"> </div>
<div class="line">remote.SetupIRCamera(IRDataType.EXTENDED);  <span class="comment">// Position, Size data</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later, after Reading from the remote</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span>[] pointer = wiimote.Ir.GetPointingPosition(); <span class="comment">// See &quot;Reading from the Remote&quot;</span></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="write-wmp"></a>
Wii Motion Plus / Wii Remote Plus</h2>
<p>If you want to check if a Wii Motion Plus is connected to the remote, you can use WiimoteApi::Wiimote::RequestIdentifyWiiMotionPlus() to ping the Wii Remote and check if one is attached. When the Wii Remote reports back its data, you can use WiimoteApi::Wiimote::wmp_attached to see if a Wii Motion Plus is attached. If you want, you can activate the Wii Motion Plus using WiimoteApi::Wiimote::ActivateWiiMotionPlus(). This makes the Wii Motion Plus behave as an extension controller (such as the nunchuck or the classic controller), and deactivates any "real" extension controllers. See <em>Reading from Extension Controllers</em> for details.</p>
<dl class="section note"><dt>Note</dt><dd>It is technically possible to put the Wiimote in a Nunchuck or Classic Controller "passthrough" mode (where you can use the nunchuck or classic controller at the same time as the Wii Motion Plus) but this is currently unsupported by the API.</dd></dl>
<p>If you want to deactivate the Wii Motion Plus (and use any extension controller connected to it such as a Nunchuck or Classic Controller) you can use WiimoteApi::Wiimote::DeactivateWiiMotionPlus().</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line">Wiimote remote; <span class="comment">// Initialized previously</span></div>
<div class="line"><span class="keywordtype">bool</span> activated = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Start() {</div>
<div class="line">    remote.RequestIdentifyWiiMotionPlus();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> Update() {</div>
<div class="line">    <span class="keywordflow">if</span> (!activated &amp;&amp; remote.wmp_attached) {</div>
<div class="line">        remote.ActivateWiiMotionPlus();</div>
<div class="line">        activated = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(activated &amp;&amp; remote.current_ext == ExtensionController.MOTIONPLUS) {</div>
<div class="line">        MotionPlusData data = remote.MotionPlus; <span class="comment">// data!</span></div>
<div class="line">        <span class="keywordtype">float</span> dPitch = data.PitchSpeed;</div>
<div class="line">        <span class="comment">// Use the data...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="read"></a>
Reading from the Remote</h1>
<p>The Wii remote automatically reports data either (1) in response to a request by WiimoteAPI (for example, when using WiimoteApi::Wiimote::SendStatusInfoRequest()) or (2) in response to user input (for example, pressing a button on the remote or changing the remote's orientation). The remote <em>only</em> reports on the data types included in its current output report (see "Changing the Data Report Mode"). Data not included in the Wii Remote's output report will not be updated.</p>
<p>To actually poll a Wii Remote for recent changes, use WiimoteApi::Wiimote::ReadWiimoteData(). This will recieve input data from the Wii Remote and interpret it. Keep in mind that the Wii Remote reads function similarly to a Queue, in FIFO (first in, first out) order. For example, if two reports were sent since the last <code>ReadWiimoteData()</code> call, the next call will only read and interpret the first of those two (and "pop" it off of the queue). So, in order to make sure you don't fall behind the Wii Remote's update frequency, you can do something like this (in a game loop for example):</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Update(Wiimote remote) { <span class="comment">// called once per frame (for example)</span></div>
<div class="line">    <span class="keywordtype">int</span> ret;</div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">        ret = remote.ReadWiimoteData();</div>
<div class="line">    } <span class="keywordflow">while</span> (ret &gt; 0); <span class="comment">// ReadWiimoteData() returns 0 when nothing is left to read.  So by doing this we continue to</span></div>
<div class="line">                       <span class="comment">// update the Wiimote until it is &quot;up to date.&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="read-interpret"></a>
Interpreting Recieved Data</h2>
<p>After recieving data through WiimoteApi::Wiimote::ReadWiimoteData(), WiimoteAPI automatically interprets and processes the raw bluetooth data into a format easily usable by your program. To access this data, use WiimoteApi::Wiimote's data fields:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field  </th><th class="markdownTableHeadNone">Contains  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">WiimoteApi::Wiimote::Accel  </td><td class="markdownTableBodyNone">AccelData: Wii Remote Accelerometer Data  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WiimoteApi::Wiimote::Button  </td><td class="markdownTableBodyNone">ButtonData: Wii Remote Button Data  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">WiimoteApi::Wiimote::Ir  </td><td class="markdownTableBodyNone">IrData: Wii Remote IR Camera Data  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">WiimoteApi::Wiimote::Status  </td><td class="markdownTableBodyNone">StatusData: Wii Remote Status Report Data  </td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="read-ext"></a>
Reading from Extension Controllers</h3>
<p>Extension controllers are automatically recognized and registered by WiimoteAPI. You can use WiimoteApi::Wiimote::current_ext to see what (if any) extension controllers are connected. You can then query one of WiimoteApi::Wiimote's extension properties based on what is connected. Here are all currently supported controllers and their WiimoteApi::Wiimote property:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Controller  </th><th class="markdownTableHeadNone">WiimoteApi::ExtensionController Enum  </th><th class="markdownTableHeadNone">WiimoteApi::Wiimote Property  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Nunchuck  </td><td class="markdownTableBodyNone">NUNCHUCK  </td><td class="markdownTableBodyNone">WiimoteApi::Wiimote::Nunchuck  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Classic Controller  </td><td class="markdownTableBodyNone">CLASSIC  </td><td class="markdownTableBodyNone">WiimoteApi::Wiimote::ClassicController  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Wii Motion Plus  </td><td class="markdownTableBodyNone">MOTIONPLUS  </td><td class="markdownTableBodyNone">WiimoteApi::Wiimote::MotionPlus  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Wii U Pro Controller  </td><td class="markdownTableBodyNone">PROCONTROLLER  </td><td class="markdownTableBodyNone">WiimoteApi::Wiimote::WiiUPro  </td></tr>
</table>
<dl class="section warning"><dt>Warning</dt><dd>Keep in mind that a Wii Motion Plus <em>must</em> be activated (see <em>Wii Motion Plus / Wii Remote Plus</em> above) in order for the Wii Remote to begin reporting Wii Motion Plus data.</dd></dl>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Update(Wiimote remote) { <span class="comment">// Called every frame (for example)</span></div>
<div class="line">    <span class="keywordflow">if</span>(remote.current_ext == ExtensionController.NUNCHUCK) {</div>
<div class="line">        NunchuckData data = remote.Nunchuck;</div>
<div class="line">        <span class="keywordtype">float</span>[] stick = data.GetStick01(); <span class="comment">// Position of the joystick</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// do stuff...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="wiiupro"></a>
Wii U Pro Controller</h3>
<p>The Wii U Pro Controller uses the same communication protocol as the Wii Remote, and acts as a Wii Remote with a special extension controller. As such, WiimoteApi treats the Wii U Pro Controller as a Wii Remote with a Wii U Pro Controller extension. Because of this accessing the Pro Controller is the same as accessing any other extension. You can also use WiimoteApi::Wiimote::Type to confirm that the connected controller is a Pro Controller (if so it will be WiimoteType.PROCONTROLLER).</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Update(Wiimote remote) { <span class="comment">// Called every frame (for example)</span></div>
<div class="line">    <span class="keywordflow">if</span>(remote.current_ext == ExtensionController.WIIU_PRO)</div>
<div class="line">    <span class="comment">// Alternatively: </span></div>
<div class="line">    <span class="comment">// if(remote.Type == WiimoteType.PROCONTROLLER)</span></div>
<div class="line">    {</div>
<div class="line">        WiiUProData data = remote.WiiUPro;</div>
<div class="line">        <span class="keywordtype">float</span> stick = data.GetLeftStick01(); <span class="comment">// Position of left joystick</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// do stuff...</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="registers"></a>
Reading and Writing to Registers</h1>
<p>The Wii Remote contains two memory modules: a 16 kilobyte EEPROM memory module, and a set of generic control registers. The EEPROM is used to store data such as calibration data and Miis from the Mii channel. The control registers can be used to manage the Wii Remote's peripherals (such as the IR Camera and any extension controllers). Internally, WiimoteAPI reads and writes to the control registers in setup features such as WiimoteApi::Wiimote::SetupIRCamera(). However, if you want to read or write to the registers yourself, you can use WiimoteApi::Wiimote::SendRegisterReadRequest(RegisterType,int,int,ReadResponder) and WiimoteApi::Wiimote::SendRegisterWriteRequest(RegisterType,int,byte[]).</p>
<p>Consult <a href="wiibrew.org/wiki/Wiimote">Wiibrew's Wii Remote data reference</a> to see where to find different types of data.</p>
<p><b>Example:</b> </p><div class="fragment"><div class="line"><span class="comment">// Example 1: Read Mii Data</span></div>
<div class="line"><span class="comment">//            See http://wiibrew.org/wiki/Wiimote/Mii_Data for implementation details.</span></div>
<div class="line"><span class="keywordtype">void</span> RespondRecieveMiiData(<span class="keywordtype">byte</span>[] data) {</div>
<div class="line">    <span class="comment">// do stuff with data[]</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> StartReadMiiData(Wiimote remote) {</div>
<div class="line">    <span class="comment">// Send an EEPROM read request to the Wiimote, starting at offset 0x0FCA, and with read length 752.</span></div>
<div class="line">    <span class="comment">// When the Wiimote finishes reporting the data, RespondRecieveMiiData(byte[]) will be called.</span></div>
<div class="line">    remote.SendRegisterReadRequest(RegisterType.EEPROM, 0x0FCA, 752, RespondRecieveMiiData);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example 2: Write IR Calibration Data</span></div>
<div class="line"><span class="comment">//            See http://wiibrew.org/wiki/Wiimote#Sensitivity_Settings for implementation details.</span></div>
<div class="line"><span class="keywordtype">void</span> WriteCalibData(Wiimote remote) {</div>
<div class="line">    <span class="comment">// Send a control register write request to the Wiimote, starting at offset 0xB0000, and with the data:</span></div>
<div class="line">    <span class="comment">// 02 00 00 71 01 00 aa 00 64</span></div>
<div class="line">    <span class="comment">// This sets the IR camera&#39;s sensitivity to level 3 (as defined by the Wii&#39;s settings menu)</span></div>
<div class="line">    remote.SendRegisterWriteRequest(RegisterType.CONTROL, 0xb00000, </div>
<div class="line">        <span class="keyword">new</span> <span class="keywordtype">byte</span>[] { 0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0xaa, 0x00, 0x64 });</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"></a>
</div><!-- doc-content -->
</div><!-- contents -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
